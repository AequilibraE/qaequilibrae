"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
RCPSP: Resource-Constrained Project Scheduling Problem.

The problem description is as follows:

You have a set of resources. They all have a maximum capacity, and
can be renewable or not.

You have a set of tasks. Each task has a list of successors, and a
list of recipes. Each recipe consists of a duration, and a list of
demands, one per resource.
The problem is always built with 2 sentinels. The first task is the source
with a set of successors. The last task is the sink, with no successors and a
zero duration.
All tasks are reachable from the source task. And the sink task is reachable
from all tasks. Furthermore, the graph has no cycles.

The tasks dependencies form a DAG with a single source and a single end.
Both source and end tasks have a zero duration, and no resource consumption.

In case the problem is of type RCPSP/Max. The data contains an additional
3D array of delays per task. This structure contains the following
information for task i with recipe ri and successor j with recipe rj, then
start(i) + delay(i, ri, j, rj) <= start(j). This subsumes the normal
successor predecence of the non RCPSP/Max variation, i.e.:
  start(i) + duration(i, mi) <= start(j).

In the normal case, the objective is to minimize the makespan of the problem.

In the resource investment problem, there is no makespan. It is
replaced by a strict deadline, and each task must finish before
this deadline.  In that case, resources have a unit cost, and the
objective is to minimize the sum of resource cost.

In the consumer/producer case, tasks have a zero duration, and demands can be
negative. The constraint states that at each time point, the sum of demands
happening before or during this time must be between the min and max
capacity. Note that in that case, both min and max capacity can be negative.
Furthermore, if 0 is not in [min_capacity, max_capacity], then a sufficient
set of events must happen at time 0 such that the sum of their demands must
fall inside the capacity interval.

The supported file formats are:
  - standard psplib (.sm and .mm):
    http://www.om-db.wi.tum.de/psplib/data.html
  - rcpsp problem in the patterson format (.rcp):
    http://www.om-db.wi.tum.de/psplib/dataob.html
  - rcpsp/max (.sch):
    https://www.wiwi.tu-clausthal.de/de/abteilungen/produktion/forschung/
          schwerpunkte/project-generator/rcpspmax/
    https://www.wiwi.tu-clausthal.de/de/abteilungen/produktion/forschung/
          schwerpunkte/project-generator/mrcpspmax/
  - resource investment problem with max delay (.sch):
    https://www.wiwi.tu-clausthal.de/de/abteilungen/produktion/forschung/
          schwerpunkte/project-generator/ripmax/
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Resource(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_CAPACITY_FIELD_NUMBER: builtins.int
    MIN_CAPACITY_FIELD_NUMBER: builtins.int
    RENEWABLE_FIELD_NUMBER: builtins.int
    UNIT_COST_FIELD_NUMBER: builtins.int
    max_capacity: builtins.int
    """The max capacity of the cumulative."""
    min_capacity: builtins.int
    """This field is used only in the consumer/producer case. It states the
    minimum capacity that must be valid at each time point.
    """
    renewable: builtins.bool
    """Indicates if the resource is renewable, that is if a task demands
    d from this resource, then the available capacity decreases by d at the
    start of the task and increases by d at the end of the task.
    """
    unit_cost: builtins.int
    """If non zero, then each unit of capacity will incur a cost of unit_cost."""
    def __init__(
        self,
        *,
        max_capacity: builtins.int = ...,
        min_capacity: builtins.int = ...,
        renewable: builtins.bool = ...,
        unit_cost: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["max_capacity", b"max_capacity", "min_capacity", b"min_capacity", "renewable", b"renewable", "unit_cost", b"unit_cost"]) -> None: ...

global___Resource = Resource

@typing.final
class Recipe(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATION_FIELD_NUMBER: builtins.int
    DEMANDS_FIELD_NUMBER: builtins.int
    RESOURCES_FIELD_NUMBER: builtins.int
    duration: builtins.int
    """The duration of the task when this recipe is selected."""
    @property
    def demands(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """In the general case, demand must be >= 0. In the consumer/producer case,
        it can be < 0. Note that in this case, the tasks always have a duration
        of zero. Thus the effect of the demand (increase or decrease of the
        current usage) happens at the start of the task.
        """

    @property
    def resources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """This parallel list indicates which resource index (in the main problem)
        the above demand corresponds to.
        """

    def __init__(
        self,
        *,
        duration: builtins.int = ...,
        demands: collections.abc.Iterable[builtins.int] | None = ...,
        resources: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["demands", b"demands", "duration", b"duration", "resources", b"resources"]) -> None: ...

global___Recipe = Recipe

@typing.final
class PerRecipeDelays(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MIN_DELAYS_FIELD_NUMBER: builtins.int
    @property
    def min_delays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        min_delays: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["min_delays", b"min_delays"]) -> None: ...

global___PerRecipeDelays = PerRecipeDelays

@typing.final
class PerSuccessorDelays(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RECIPE_DELAYS_FIELD_NUMBER: builtins.int
    @property
    def recipe_delays(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PerRecipeDelays]: ...
    def __init__(
        self,
        *,
        recipe_delays: collections.abc.Iterable[global___PerRecipeDelays] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["recipe_delays", b"recipe_delays"]) -> None: ...

global___PerSuccessorDelays = PerSuccessorDelays

@typing.final
class Task(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESSORS_FIELD_NUMBER: builtins.int
    RECIPES_FIELD_NUMBER: builtins.int
    SUCCESSOR_DELAYS_FIELD_NUMBER: builtins.int
    @property
    def successors(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The indices of the successors tasks in the main problem."""

    @property
    def recipes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Recipe]:
        """The list of possible ways to execute the task."""

    @property
    def successor_delays(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PerSuccessorDelays]:
        """If the current task has n successors and m recipes then this is
        an n x m matrix where each entry at line i is a vector with the
        same length as the number of recipes for the task successor[i]. If
        recipe m1 is chosen for the current task, and recipe m2 is chosen
        for its successor i, we have:
           start(current_task) + delay[i][m1][m2] <= start(successor_task).
        """

    def __init__(
        self,
        *,
        successors: collections.abc.Iterable[builtins.int] | None = ...,
        recipes: collections.abc.Iterable[global___Recipe] | None = ...,
        successor_delays: collections.abc.Iterable[global___PerSuccessorDelays] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["recipes", b"recipes", "successor_delays", b"successor_delays", "successors", b"successors"]) -> None: ...

global___Task = Task

@typing.final
class RcpspProblem(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOURCES_FIELD_NUMBER: builtins.int
    TASKS_FIELD_NUMBER: builtins.int
    IS_CONSUMER_PRODUCER_FIELD_NUMBER: builtins.int
    IS_RESOURCE_INVESTMENT_FIELD_NUMBER: builtins.int
    IS_RCPSP_MAX_FIELD_NUMBER: builtins.int
    DEADLINE_FIELD_NUMBER: builtins.int
    HORIZON_FIELD_NUMBER: builtins.int
    RELEASE_DATE_FIELD_NUMBER: builtins.int
    TARDINESS_COST_FIELD_NUMBER: builtins.int
    MPM_TIME_FIELD_NUMBER: builtins.int
    SEED_FIELD_NUMBER: builtins.int
    BASEDATA_FIELD_NUMBER: builtins.int
    DUE_DATE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    is_consumer_producer: builtins.bool
    """Problem type."""
    is_resource_investment: builtins.bool
    is_rcpsp_max: builtins.bool
    deadline: builtins.int
    """If set, it defines a strict date, and each task must finish before this."""
    horizon: builtins.int
    """Additional info stored in the source file.
    The horizon is a date where we are sure that all tasks can fit before it.
    """
    release_date: builtins.int
    """The release date is defined in the rcpsp base format, but is not used."""
    tardiness_cost: builtins.int
    """The tardiness cost is defined in the rcpsp base format, but is not used."""
    mpm_time: builtins.int
    """The mpm_time is defined in the rcpsp base format, but is not used.
    It is defined as the minimum makespan in case of interruptible tasks.
    """
    seed: builtins.int
    """Data used by the problem generator."""
    basedata: builtins.str
    due_date: builtins.int
    """The due date is defined in the rcpsp base format, but is not used."""
    name: builtins.str
    @property
    def resources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Resource]:
        """Problem data."""

    @property
    def tasks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Task]: ...
    def __init__(
        self,
        *,
        resources: collections.abc.Iterable[global___Resource] | None = ...,
        tasks: collections.abc.Iterable[global___Task] | None = ...,
        is_consumer_producer: builtins.bool = ...,
        is_resource_investment: builtins.bool = ...,
        is_rcpsp_max: builtins.bool = ...,
        deadline: builtins.int = ...,
        horizon: builtins.int = ...,
        release_date: builtins.int = ...,
        tardiness_cost: builtins.int = ...,
        mpm_time: builtins.int = ...,
        seed: builtins.int = ...,
        basedata: builtins.str = ...,
        due_date: builtins.int = ...,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["basedata", b"basedata", "deadline", b"deadline", "due_date", b"due_date", "horizon", b"horizon", "is_consumer_producer", b"is_consumer_producer", "is_rcpsp_max", b"is_rcpsp_max", "is_resource_investment", b"is_resource_investment", "mpm_time", b"mpm_time", "name", b"name", "release_date", b"release_date", "resources", b"resources", "seed", b"seed", "tardiness_cost", b"tardiness_cost", "tasks", b"tasks"]) -> None: ...

global___RcpspProblem = RcpspProblem

@typing.final
class RcpspAssignment(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_OF_TASK_FIELD_NUMBER: builtins.int
    SELECTED_RECIPE_OF_TASK_FIELD_NUMBER: builtins.int
    @property
    def start_of_task(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    @property
    def selected_recipe_of_task(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        start_of_task: collections.abc.Iterable[builtins.int] | None = ...,
        selected_recipe_of_task: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["selected_recipe_of_task", b"selected_recipe_of_task", "start_of_task", b"start_of_task"]) -> None: ...

global___RcpspAssignment = RcpspAssignment
